title:      PsPs 0x01
date:       Dec 01, 2016
properties: probset

## Contents

* 0x0100 Fork with buffer
* 0x0101 C magic in encoding? Nah
* 0x0102 File or dir, ternarily
* 0x0103 Sup, `mymap`?

## 3. Sup, `mymap`?

> *Wow! A bonus!* Well actually it didn't wow you right? Anyway off we go.

Recently I heard about *Ur/Web* from my friend, fascinated by its well-known
benchmarking highlights and functional syntax unlike *Lisp*. But, for some
reason that might derive from a bitbucket, I didn't choose to pick up the basis
of some *ML*-family languages like *Haskell* and *OCaml*, but downloaded and
installed [Standard ML of New Jersey](http://www.smlnj.org/) (`smlnj`) to give
it a shot. There are many great tutorials and by-example guides to help with
learning this good ol' language, and I simply got
[this Learning-Standard-ML-In-Y-Minutes snippet](https://learnxinyminutes.com/docs/standard-ml/)
with less than 200 lines of code and 100+ lines of really helpful and qualified
comments. Feel free to have a try in the suffusion of blue of the functional
universe. `:D`

> *Hey so where the hell is the problem?*

Pattern matching and infix operators are, at first sight, kinda eerie but
attention-grabbing. And I noticed the implementation of `map` just looked so
tight and it basically blew my mind. Check it out:

```sml
fun map f [] = []
  | map f (x::xs) = f(x) :: map f xs
```

The second match of `map` could destructure the first element of the list and
invoke itself with the rest of the elements as the argument. *Holy shmoly.*

So at the moment I just asked myself... How we implemented it in the imperative
world? In Python I thought it was easy to deal with. Destructuring the first
item and recursive invocation are not actually unrealistic, but it doesn't come
so naturally in a *pythonic* way. We could iterate with the given list, call
the function with its items, and finally add the results to a temporary list for
returning. However, as you can tell, list comprehension could ease this pain.

```python
def mymap(func, lst):
    return [func(i) for i in lst]
```

> Bam! Not a problem yo!

Surely it is painless. But meanwhile I re-examined the usage of `map()` in py35,
where it could map multiple *iterables* (e.g. `list`, `set`) in parallel. For
instance:

```python
>>> list(map(lambda x, y: x * y, [1, 2], [3, 4]))
[3, 8]
```
So why not extend our little `mymap()` for a better use? It's not that
complicated anyway, where an `*` operator and a `zip()` are the keys to the
solutions.

```python
mymap = lambda func, lst, *lsts: [func(*i) for i in zip(lst, *lsts)]
```

Oops, I just bound a lambda function to `mymap`, which might look more compact
and subtle. Note that `map()` in Python is implemented in C
([source here](https://hg.python.org/cpython/file/tip/Python/bltinmodule.c#l940))
which returns an iterable object called `map`. Hence It is well-supported and
please hug this built-in goodness!

Anyway, `mymap` doesn't look so bad, I think.

## TBC

Got some suggestions? Some corrections, perhaps? Feel free to reach me and point
them out. *And please stay tuned!*
